# 跨越进程边界共享内核对象

统一 : 句柄表中的**项目的索引**称之为**句柄**

> 为何需要共享的原因

- 文件映射对象：使你能够在同一台机器上运行的两个进程之间共享数据块
- 邮箱和指定的管道：使应用程序能够在连网的不同机器上运行的进程之间发送数据块
- 互斥对象、信标和事件对象：使得不同进程中的线程能够同步它们的连续运行，这与一个应用程序在完成某项任务时需要将情况通知给另外一个应用程序的情况相同。

#### **对象句柄的继承性**

只有当进程具有父子关系，才能使用对象句柄的继承性。

父进程可以决定生成一个子进程，为子进程赋予对父进程的内核对象的访问权限。

为了实现这种继承，父进程需要执行几个操作。

->	首先，当父进程创建内核对象时，必须向系统指明该句柄是可继承的。（创建时PSECURITY_ATTRIBUTES被指定，而非NULL,设置SECURITY_ATTRIBUTE中的成员bInheritable为TRUE，即可继承的）

->	句柄表中项目的标志位为0说明，PSECUTIRY_ATTRIBUTES被指定为NULL，因此为1则可继承

->	父进程创建子进程  CreateProcess （后面章节会详细介绍用法）

创建父进程设置可继承----设置为继承创建进程----进程初始化句柄表----从父进程中拷贝可被继承的句柄的项目到子进程句柄表中（句柄继承，因此位置相同，即索引相同）----递增内核对象的使用计数

> 注意

对象句柄的的继承性只在生成的时候使用（拷贝），如果子进程已经都创建好了之后，父进程又创建了新的内核对象，那么子进程是无法继承到该内核对象句柄的。

> 攻略

子进程并不知道他自己继承的什么内核对象的句柄值，因此，父进程可以通过指定命令行参数的方式传递句柄值给子进程（子进程期望的句柄值）（这样做的前提当然是因为继承后句柄值是一样的）

->	当然，可以使用其他形式的进程间通讯传递句柄值

1. 例如：让父进程等待子进程创建完成初始化后，父进程将一条消息发送或展示在子进程的一个线程创建的	窗口中

2. 让父进程将一个环境变量添加给他的环境程序块，该变量的名字是子进程知道要查找的某种信息，而值是内核对象要继承的值（句柄值），子进程生成后，获取继承的环境变量获取句柄值。

   （如果子子孙孙继承下去，这种方法是极好的，因为环境变量也是一直继承下去的）

   ​

#### **改变句柄的标志**

> 多个子进程时，控制哪个可以可以继承

这样的话，我们就需要控制句柄的标志位 0 和 1的设置

使用函数SetHandleInfomation（）

->	Handle hObject  // 句柄

->	DWORD dwMask // 改变哪个值 可以 | 起来多个

->	DWORD dwFlags // 变成什么值

例如设置为可继承：

SetHandleInformation（hObj，HANDLE_FLAG_INHERIT，HANDLE_FLAG_INHERIT);

GetHandleInformation可获取标志位的值

#### 命名对象

共享跨越进程边界的内核对象的第二种方法是给对象命名（注意不是全部内核对象都可以命名）

如：HANDLE   CreateMutex(...);其中有个参数 PCTSTR pszName指明了命名

也就是说，有的内核对象创建时让我们可以在创建时指定名字 (NULL 则无命名)



Precess A调用CreateMutex ，对象被命名为“TA”

Precess B调用CreateMutex，对象被命名为“TA”

则B发现已经存在，那么会去确定是否拥有访问权限，是否该名字也是同样的Mutex对象，是就去B的句柄表中增加项目，这样该对象的计数就递增1，实现共享。

CreateMutex和OpenMutex的区别在于，不存在则Create会创建而Open会报错（返回NULL）（ERROR:ERROR_FILE_NOT_FOUND等）

> 命名对象通常用来防止一个应用程序多个实例

如何知道一个名字的对象已经存在，用GertLastError

如：检查Create...函数是否是得到共享对象还是创建了新的

```
CreateMutex...
if(GetLastError() == ERROR_ALREADY_EXISTS)
{
	// 该对象已经存在  （若是不同线程则当前新线程得到共享）
}else
}
	// 不存在 则上面的CreateMutex是创建新的
}
```

#### 终端服务器的命名空间

终端服务器拥有内核对象的多个命名空间供客户端程序使用，此外，每个客户程序有他自己的命名空间

```c++
HANDLE h = CreateEvent(NULL,FALSE,"Global\\MyName"); // Global\  使得进入全局名字空间
HANDLE h = CreateEvent(NULL,FALSE,"Local\\MyName");// Local\   使得进入会话名字空间
```

#### 复制对象句柄

共享跨越边界的内核对象的最后一个方法是使用DuplicateHandle函数（拷贝句柄表中的某个项目）

参数：

源进程内核对象句柄（被访问的）

内核对象句柄

目标进程内核对象句柄（要访问的）

内核对象句柄地址（获取复制后的内核对象的句柄）

描述（选项为0则设置这边  选项不为0则描述设置为0）

继承

选项（DUPLICATE_SAME_ACCESS 和 DUPLICATE_CLOSE_SOURCE的任意组合  或者  有了描述  这边设置为0）





