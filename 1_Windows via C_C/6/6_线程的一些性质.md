## 线程的一些性质

> 如何来实现？

CreateThread使系统创建一个线程内核对象，该对象的初始计数是2（线程运行+1，返回句柄+1），退出代码STILL_ACTIVE，线程对象被设置为未通知，暂停次数为1。



一旦线程内核对象创建成功，系统就分配用于线程的堆栈的内存。该内存是从进程的地址空间中分配的，因为线程并不拥有他自己的地址空间。然后将pcParam和pfnStartAdd依次j写入堆栈（从高地址写向低地址）。



每个线程都有它自己的一组CPU寄存器，成为线程的上下文，反映了线程上次运行时该线程的CPU寄存器状态。线程的这组CPU寄存器保存在一个CONTEXT结构中。CONNEXT结构则被包含在线程的内核对象中。



指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器。

线程总是在进程的上下文中运行的。

线程内核对象被初始化时：

堆栈指针寄存器被设置为pfnStartAddr的地址

指令指针寄存器被设置为BaseThreadStart的函数地址中（该函数在Kernel32.dll中，也就是CreateThread函数实现的地方）



当线程完成初始化后，系统查看CREATE_SUPEDNED标志是否已经传递给CreateThread，如果没有，则线程的暂停计数被设置为0，线程可以被调度到一个进程中。然后系统中上次保存在线程上下文中的值加载到实际的CPU寄存器中。这时，线程就可以执行代码了，并对他的进程的地址空间中的数据进行操作。

因为新线程的指令指针是被设置为BaseThreadStart（参数是线程函数地址和参数）的，因此，该函数是线程开始执行的地方，当执行时：

- 在线程函数中建立一个结构化异常处理（SEH）帧，这样线程执行时产生的任何异常情况都会得到系统的某种默认处理。

- 系统调用线程函数，并传递参数

- 当线程函数返回时，BaseThreadStart调用了ExitThread函数，将线程的返回值传递给他。线程内核对象的使用计数递减。

- 如果线程产生一个没有处理的异常条件，由BaseThreadStart函数建立的SEH帧将负责处理该异常。通常会显示消息框，一旦关闭消息框，BaseThreadStart就会调用ExitThread终止整个进程的运行，而不只是终止线程的运行。

  ​

BaseThreadStart是不返回的，要么调用ExitThread要么调用ExitProcess结束，他将线程函数的返回地址放入堆栈，这样就知道在何处返回了。



当进程的主线程被初始化时，他的指令指针被设置为另外一个未文档化的函数：

BaseProcessStart（参数是主线程函数地址）

功能和BaseThreadStart一样，差别是参数没有带pvParam。

当该函数开始执行时，他调用了C/C++运行期库启动代码，启动代码初始化入口点函数，然后调用这些入口点函数，当入口点函数返回时，C/C++运行期库的启动代码就调用ExitProcess，因此，对于C/C++应用程序来说，主线程从不返回BaseProcessStart，这是和BaseThreadStart不同的地方。